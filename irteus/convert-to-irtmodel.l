(setq no-gen t)
(load "~/prog/rats/convert-model.l")

(unless (fboundp 'format-org)
  (setf (symbol-function 'format-org) (symbol-function 'format)))
(defun convert-to-relocatable-vector (l)
  (mapcar #'(lambda (a)
	      (cond 
	       ((listp a)
		(append (list 'list) (convert-to-relocatable-vector a)))
	       ((float-vector-p a)
		(append (list 'float-vector) (coerce a cons)))
	       ((integer-vector-p a)
		(append (list 'integer-vector) (coerce a cons)))
	       (t a)))
	  l)
  )
(defun format (strm format-string &rest args)
  (apply #'format-org strm format-string (convert-to-relocatable-vector args)))

(defun dump-irtrobot-link (robot ulinks name &optional (ostrm t))
  (let (link rl ob i)
    (when name
      (setq link (find-if #'(lambda (x) (eq name (assoc2 :name x))) ulinks))
      (setq rl (find-if #'(lambda (x) (eq (send x :name) (assoc2 :name link))) (send robot :links)))
      (when rl
	
	(format ostrm "     ;; definition of ~A~%" (send rl :name))
	(format ostrm "     (setq bc (list~%" )
	(dolist (b (send rl :bodies))
	  (format ostrm "       (instance faceset :init :faces (list~%")
	  (dolist (f (send b :faces))
	    (format ostrm "         (instance face :init :vertices ~A"
		    (flatten (or (mapcar #'(lambda (p) 
					     (send rl :inverse-transform-vector p))
					 (cdr (send f :vertices)))
				 (send rl :vertices)
				 )			     			     
			     ))
	    (when (send f :holes)
	      (format ostrm "~%                              :holes (list~%")
	      (dolist (h (send f :holes))
		(format ostrm "         (instance hole :init :vertices ~A)~%"
			(mapcar
			 #'(lambda (p) (send rl :inverse-transform-vector p))
			 (cdr (send h :vertices))))
		)
	      (format ostrm ")")
	      )
	    (format ostrm ")~%")
	    )
	  (format ostrm "       ))~%")
	  )
	(format ostrm "       ))~%")
	(format ostrm "     (dolist (b (cdr bc)) (send (car bc) :assoc b))~%" )
	(setq i 0)
	(dolist (b (send rl :bodies))
	  (format ostrm "     (send (elt bc ~A) :set-color ~A)~%"
		  i
		  (cond ((symbolp (get b :face-color))
			 (get b :face-color))
			((send (get b :face-color) :name)
			 (send (get b :face-color) :name))
			(t
			 (send (gl::find-color (send (get b :face-color) :ambient)) :name))))
	  (incf i))
	(format ostrm "     (setq blink~A (instance bodyset-link :init (make-cascoords) :bodies bc :name ~A :weight ~A :centroid ~A :inertia-tensor ~A))~%"
		(assoc2 :id link) (send rl :name)
		(send rl :weight) (send rl :get :centroid) (send rl :get :inertia-tensor))
	(format ostrm "~%")
	(dump-irtrobot-link robot ulinks (assoc2 :child link) ostrm)
	(dump-irtrobot-link robot ulinks (assoc2 :sister link) ostrm)
	)
      )
    ))

(defun push-assoc-code (robot ulinks name)
  (let (link rl)
    (if name
	(progn 
	  (setq link (find-if #'(lambda (x) (eq name (assoc2 :name x))) ulinks))
	  (setq parent-link (find-if #'(lambda (x) (eq (assoc2 :mother link) (assoc2 :name x))) ulinks))
	  (setq rl (find-if #'(lambda (x) (eq (send x :name) (assoc2 :name link))) (send robot :links)))
	  (setq prl (find-if #'(lambda (x) (eq (send x :name) (assoc2 :name parent-link))) (send robot :links)))
	  (when rl
	    (when parent-link	  
	      (push (format nil "     (send blink~A :assoc blink~A)~%" (assoc2 :id parent-link) (assoc2 :id link)) ret)
	      (push (format nil "     (send blink~A :translate ~A :world)~%" (assoc2 :id link) (assoc2 :b link)) ret)
	      )
	    (push-assoc-code robot ulinks (assoc2 :sister link))
	    (push-assoc-code robot ulinks (assoc2 :child link))
	    )
	  )
      )
    ))

(defun dump-irtrobot-assoc (robot ulinks name &optional (ostrm t))
  (setq ret nil)
  (push-assoc-code robot ulinks name)
  (dolist (r ret)
    (format ostrm r)
    )
  )

(defun dump-irtrobot-joint (robot ulinks &optional (ostrm t))
  (let (parent-link child-link)
    (dolist (j (send robot :joint-list)) 
      (setq child-link (find-if #'(lambda (x) (eq (send (send j :child-link) :name) (assoc2 :name x))) ulinks))
      (setq parent-link (find-if #'(lambda (x) (eq (send (send j :parent-link) :name) (assoc2 :name x))) ulinks))
      (format ostrm "     ;; definition of ~A~%" (send j :name))
      (format ostrm "     (setq joint~A (instance ~A-joint :init
			     :parent-link blink~d :child-link blink~d :name ~10A :axis ~3A
			     :min ~6,1f :max ~6,1f))~%" 
	      (1- (assoc2 :id child-link))
	      (if (derivedp j rotational-joint) "rotational" "linear")
	      (assoc2 :id parent-link)
	      (assoc2 :id child-link)
	      (if (find-method robot :limbs)
		  (format nil "~A-~A" (send (find-limb-from-sj j robot) :name)
			  (string-downcase (string (send j :name))))
		(format nil "~A" (send j :name)))
	      (j . axis)
	      (send j :min-angle) 
	      (send j :max-angle)
	      )
      (format ostrm "~%")
      )
    ))

(defun dump-irtrobot-end-coords (ulinks offsets &optional (ostrm t))
  (let (parent-link limb-name)
    (dolist (o offsets)
      (setq limb-name (string-left-trim ":" (format nil "~A" (assoc2 :name o))))
      (setq parent-link (find-if #'(lambda (x) (eq (assoc2 :parent-name o) (assoc2 :name x))) ulinks))
      (format ostrm "     ;; definition of ~A-end-coords~%" limb-name)
      (format ostrm "     (setq ~A-end-coords
       (make-cascoords
	:coords (send (send blink~d :copy-worldcoords) :transform 
		      (make-coords :pos ~A :rot ~A))))
     (send blink~d :assoc ~A-end-coords)~%"
	      limb-name
	      (assoc2 :id parent-link)
	      (assoc2 :offset-pos o)
	      (assoc2 :offset-rot o)
	      (assoc2 :id parent-link)
	      limb-name)
      (format ostrm "~%")
      )
    ))

(defun dump-irtrobot-collision-avoidance-link-pair (ulinks pairs &optional (ostrm t))
  (let (link0 link1)
    (format ostrm "     ;; definition of collision-avoidance-link-pair~%")
    (format ostrm "     (setq collision-avoidance-link-pair~%       (list~%")
    (dolist (p pairs)
      (setq link0 (find-if #'(lambda (x) (eq (elt p 0) (assoc2 :name x))) ulinks))
      (setq link1 (find-if #'(lambda (x) (eq (elt p 1) (assoc2 :name x))) ulinks))
      (format ostrm "        (list blink~d blink~d)~%"
	      (assoc2 :id link0)
	      (assoc2 :id link1)
	      ))
    (format ostrm "        ))~%")
    ))

(defun dump-irtrobot-sensor-coords (ulinks offsets &optional (ostrm t))
  (let (parent-link limb-name o sensor-type)
    (dotimes (i (length offsets))
      (setq o (elt offsets i))
      (setq sensor-type (reg-replace "_" "-" (assoc2 :sensor-type o)))
      (setq parent-link (find-if #'(lambda (x) (eq (assoc2 :parent-name o) (assoc2 :name x))) ulinks))
      (setq limb-name (string-downcase (assoc2 :limb parent-link)))
      (format ostrm "     ;; definition of ~A ~A-coords~%" limb-name sensor-type)
      (format ostrm "     (setq sensor~d
       (make-cascoords
	:coords (send (send blink~d :copy-worldcoords) :transform 
		      (make-coords :pos ~A :rot ~A))
        :name \"~A-~A~A\"))
     (send blink~d :assoc sensor~d)~%"
	      i
	      (assoc2 :id parent-link)
	      (assoc2 :offset-pos o)
	      (assoc2 :offset-rot o)
	      limb-name sensor-type (assoc2 :no o)
	      (assoc2 :id parent-link) i)
      (format ostrm "~%")
      )
    (format ostrm "     (setq sensors (list")
    (dotimes (i (length offsets)) (format ostrm " sensor~d" i))
    (format ostrm "))~%")
    ))

(defun jskrobot-to-irtrobot (robot ulinks offsets pairs sensors &optional (ostrm t))
  (let (i cl check pstate)
    (setq pstate (send robot :state))
    (format ostrm "(defclass ~A-robot~%" (string-downcase (send robot :name)))
    (format ostrm "  :super robot-model~%")
    (format ostrm "  :slots (sensors))~%")
    (format ostrm "(defmethod ~A-robot~%" (string-downcase (send robot :name)))
    (format ostrm "  (:init~%")
    (format ostrm "   (&rest args)~%")
    (format ostrm "   (let (c bc~%")
    (format ostrm "        ")
    (dotimes (i (length ulinks)) (format ostrm " blink~d" i)) (format ostrm "~%")
    (format ostrm "        ")
    (dotimes (i (length ulinks)) (format ostrm " joint~d" i)) (format ostrm "~%")
    (format ostrm "        ")
    (dotimes (i (length sensors)) (format ostrm " sensor~d" i)) (format ostrm "~%")
    (format ostrm "         )~%")
    (format ostrm "     (send-super* :init args)~%")
    (format ostrm "~%")
    (format ostrm "     ;; definition of link~%")
    (format ostrm "~%")
    (dump-irtrobot-link robot ulinks :root ostrm)
    (format ostrm "     ;; definition of assoc~%")   
    (dump-irtrobot-assoc robot ulinks :root ostrm)
    (format ostrm "     (send blink0 :translate ~A :world)~%" (send robot :worldpos))
    (format ostrm "     (send self :assoc blink0)~%")
    (format ostrm "~%")
    (format ostrm "     ;; definition of end-coords~%")
    (format ostrm "~%")
    (dump-irtrobot-end-coords ulinks offsets ostrm)
    (format ostrm "     ;; definition of joint~%")
    (format ostrm "~%")
    (dump-irtrobot-joint robot ulinks ostrm)
    ;;
    (when (find-method *robot* :limbs)
      (dolist (limb (send *robot* :limbs))
	(format ostrm "     (setq ~A-root-link blink~A)~%" 
		(string-downcase (string (send limb :name)))
		(assoc2 :id (find-if #'(lambda (x) (eq (send (car (send limb :links)) :name) (assoc2 :name x))) ulinks)))
	(format ostrm "     (setq ~A (list" (string-downcase (string (send limb :name))))
	(dolist (n (send-all (send limb :links) :name))
	  (format ostrm " blink~A" (assoc2 :id (find-if #'(lambda (x) (eq n (assoc2 :name x))) ulinks))))
	(format ostrm "))~%")
	))
    (format ostrm "     (setq links (list")
    (dotimes (i (length (send robot :links))) (format ostrm " blink~A" i))
    (format ostrm "))~%")
    (format ostrm "     (setq joint-list (list")
    (dotimes (i (length (send robot :joint-list))) (format ostrm " joint~A" i))
    (format ostrm "))~%")
    (dump-irtrobot-collision-avoidance-link-pair ulinks pairs ostrm)
    (format ostrm "~%")
    (dump-irtrobot-sensor-coords ulinks sensors ostrm)
    (format ostrm "     (send self :init-ending)~%")
    (format ostrm "     self))~%")
    (when (find-method robot :reset-pose)
      (send robot :reset-pose)
      (format ostrm "  (:reset-pose () (send self :angle-vector ~A))~%" (send robot :angle-vector)))
    (format ostrm "  )~%")
    (format ostrm "~%")
    (format ostrm "(format *error-output* \"(instance ~A-robot :init) for generating model~~%\")~%" (string-downcase (send robot :name)))
    (send robot :state pstate)
    ))

(setq fname (format nil "~A-model.l" (string-downcase (send *robot* :name))))
(format *error-output* ";; writing to ... ~A~%" fname)
(with-open-file 
 (ostrm (format nil "~A" fname) :direction :output)
 (format ostrm "
(defun make-faceset-from-vertices (vs)
  (let ((fs))
    (while vs
      (print (list (elt vs 0) (elt vs 1) (elt vs 2)))
      (push (make-face-from-vertices (list (pop vs)(pop vs) (pop vs))) fs)
      )
    (instance faceset :init :faces fs)
    ))
")
 (jskrobot-to-irtrobot *robot* *r* *o* *p* *s* ostrm)
 )
