<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//JP">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>実際のロボットモデル</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<META NAME="description" CONTENT="実際のロボットモデル">
<META NAME="keywords" CONTENT="jmanual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="jmanual.css">

<LINK REL="previous" HREF="jmanual-node168.html">
<LINK REL="up" HREF="jmanual-node166.html">
<LINK REL="next" HREF="jmanual-node170.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html3008"
  HREF="jmanual-node170.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html3002"
  HREF="jmanual-node166.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2998"
  HREF="jmanual-node168.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html3004"
  HREF="jmanual-node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html3006"
  HREF="jmanual-node187.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html3009"
  HREF="jmanual-node170.html">ロボットモデル</A>
<B> Up:</B> <A NAME="tex2html3003"
  HREF="jmanual-node166.html">ロボットの動作生成プログラミング</A>
<B> Previous:</B> <A NAME="tex2html2999"
  HREF="jmanual-node168.html">irteusのサンプルプログラムにおける例</A>
 &nbsp; <B>  <A NAME="tex2html3005"
  HREF="jmanual-node1.html">Contents</A></B> 
 &nbsp; <B>  <A NAME="tex2html3007"
  HREF="jmanual-node187.html">Index</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H3><A NAME="SECTION05013300000000000000">
実際のロボットモデル</A>
</H3>

<P>
実際のロボットや環境を利用した実践的なサンプルプログラムを見てみよう．

<P>
まず，最初はロボットや環境のモデルファイルを読み込む．これらのファイル
は$EUSDIR/modelsに，これらのファイルをロードしインスタンスを生成す
るプログラムは以下のように書くことができる．<code>(room73b2)</code>や
<code>(h7)</code>はこれらのファイル内で定義されている関数である．
ロボットのモデル(<code>robot-model</code>)は<code>irtrobot.l</code>ファイルで定義
されており，<code>cascaded-link</code>クラスの子クラスになっている．
ロボットとは<code>larm,rarm,lleg,rleg,head</code>のリンクのツリーからなる
ものとして定義されており，
<code>(send *robot* :larm)</code>や<code>(send *robot* :head)</code>として
ロボットのリム(limb)にアクセスでき，右手の逆運動学，左手の逆運動学等と
いう利用方法が可能になっている．

<P>
<PRE>
(load "models/room73b2-scene.l")
(load "models/h7-robot.l")
(setq *room* (room73b2))
(setq *robot* (h7))
(objects (list *robot* *room*))
</PRE>

<P>
ロボットには<code>:reset-pose</code>というメソッドがありこれで初期姿勢をとる
ことができる．
<PRE>
(send *robot* :reset-pose)
</PRE>

<P>
次に，ロボットを部屋の中で移動させたい．部屋内の代表的な座標は
<code>(send *room* :spots)</code>で取得できる．この中から目的の座標を得る
場合はその座標の名前を引数として<code>:spot</code>メソッドを呼び出す．
ちなみに，このメソッドの定義は<code>prog/jskeus/irteus/irtscene.l</code>
にあり
<PRE>
(defmethod scene-model
  (:spots
   (&amp;optional name)
   (append
    (mapcan
     #'(lambda(x)(if (derivedp x scene-model) (send x :spots name) nil))
     objs)
    (mapcan #'(lambda (o)
		(if (and (eq (class o) cascaded-coords)
			 (or (null name) (string= name (send o :name))))
		    (list o)))
	    objs)))
  (:spot
   (name)
   (let ((r (send self :spots name)))
     (case (length r)
       (0 (warning-message 1 "could not found spot(~A)" name) nil)
       (1 (car r))
       (t (warning-message 1 "found multiple spot ~A for given name(~A)" r name) (car r)))))
  )
</PRE>
となっている．

<P>
ロボットもまた<code>coordinates</code>クラスの子クラスなので<code>:move-to</code>
メソッドを利用できる．また，このロボットの原点は腰にあるので足が地面に
つくように<code>:locate</code>メソッドを使って移動する．
<PRE>
(send *robot* :move-to (send *room* :spot "cook-spot") :world)
(send *robot* :locate #f(0 0 550))
</PRE>

<P>
現状では<code>*irtviewer*</code>の画面上でロボットが小さくなっているので，
以下のメソッド利用し，ロボットが画面いっぱいになるように調整する．
<PRE>
(send *irtviewer* :look-all
      (geo::make-bounding-box
       (flatten (send-all (send *robot* :bodies) :vertices))))
</PRE>

<P>
次に環境中の物体を選択する．ここでは<code>:object</code>メソッドを利用する．
これは，<code>:spots, :spot</code>と同様の振る舞いをするため，
どのような物体があるかは，<code>(send-all (send *room* :objects) :name)</code>
として知ることができる．
<code>room73b2-kettle</code>の他に
<code>room73b2-mug-cup</code>や<code>room73b2-knife</code>等を利用するとよい．

<P>
<PRE>
(setq *kettle* (send *room* :object "room73b2-kettle"))
</PRE>

<P>
環境モデルの初期化直後は物体は部屋にassocされているため，以下の用に
親子関係を解消しておく．こうしないと物体を把持するなどの場合に問題が生
じる．
<PRE>
(if (send *kettle* :parent) (send (send *kettle* :parent) :dissoc *kettle*))
</PRE>

<P>
ロボットの視線を対象物に向けるためのメソッドとして以下のようなものがあ
る．
<PRE>
(send *robot* :head :look-at (send *kettle* :worldpos))
</PRE>

<P>
対象物体には，その物体を把持するための利用したらよい座標系が
<code>:handle</code>メソッドとして記述されている場合がある．このメソッドは
リストを返すため以下の様に<code>(car (send *kettle* :handle))</code>として
その座標系を知ることができる．この座標がどこにあるか確認するためには
<code>(send (car (send *kettle* :handle)) :draw-on :flush t)</code>とすると
よい．

<P>
したがってこの物体手を伸ばすためには
<PRE>
(send *robot* :larm :inverse-kinematics
      (car (send *kettle* :handle))
      :link-list (send *robot* :link-list (send *robot* :larm :end-coords :parent))
      :move-target (send *robot* :larm :end-coords)
      :rotation-axis :z
      :debug-view t)
</PRE>
となる．

<P>
ここで，ロボットの手先と対象物体の座標系を連結し，
<PRE>
(send *robot* :larm :end-coords :assoc *kettle*)
</PRE>

<P>
以下の様にして世界座標系で100[mm]持ち上げることができる．
<PRE>
(send *robot* :larm :move-end-pos #f(0 0 100) :world
        :debug-view t :look-at-target t)
</PRE>
<code>:look-at-target</code>は移動中に首の向きを常に対象を見つづけるようにす
るという指令である．

<P>
<BR><HR>
<ADDRESS>

2015-10-11
</ADDRESS>
</BODY>
</HTML>
